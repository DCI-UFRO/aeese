{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Componentizing Autonomous Underwater Vehicles by Physical-runnning Algorithms","text":"<p>The research experiment outlined on this page presents an architecture designed for componentizing autonomous underwater vehicles, utilizing direct physical-runnning algorithms. Specifically, a genetic algorithm (GA) operates directly on a physical component to identify its notable operational points. The associated diagram delineates the interrelation of seven key elements in accordance with this architectural framework, facilitating evaluation in a cyber-physical loop. These elements include a computer, a controller, two sensors (for power consumption and thrust acquisition), a motor driver, a power supply, and a DC motor. For this experiment, the chosen controller was the Atmel SAMD21 board (Arduino MKR1000). This controller is adept at transmitting and receiving multiple data streams over serial communication interfaced with either Matlab or R software. This software is hosted on the computer where the genetic algorithm operates. The employed sensors comprised a strain gauge, utilized for assessing the thrust generated by the DC motor, and a current sensor, used for power consumption measurement. The combined function of the power supply and motor driver is to energize the motor. Using a PWM signal, the GA has the capability to adjust the motor's rotational intensity.</p>"},{"location":"actuadores/","title":"Actuator","text":""},{"location":"actuadores/#motor-driver","title":"Motor Driver","text":"<p>The L298N driver is utilized to supply energy to the motor from an external power source and to regulate the motor's operation using a PWM signal.</p> <p></p>"},{"location":"actuadores/#motor","title":"Motor","text":"<p>In the experiment, a generic 12V DC motor was utilized.</p> <p></p>"},{"location":"controlador/","title":"Controller","text":""},{"location":"controlador/#arduino","title":"Arduino","text":"<p>For the experiment, a controller with efficient serial port communication capabilities was essential. The chosen device for this purpose was the Arduino MKR1000.</p> <p></p>"},{"location":"controlador/#sensors","title":"Sensors","text":"<p>The controller is required to have a minimum of two analog pins available for the connection of the following sensors:</p> <ol> <li>Thrust sensor</li> <li>Current Sensor</li> </ol>"},{"location":"controlador/#actuator","title":"Actuator","text":"<p>The actuator necessitates only a PWM pin from the controller to supply power to the motor via a motor driver. </p>"},{"location":"documentacion/","title":"Code in the Arduino","text":""},{"location":"documentacion/#sensors","title":"Sensors","text":""},{"location":"documentacion/#thrust-sensor","title":"Thrust Sensor","text":"<p>To implement the strain gauge, an external library is required. This library can be found in the Arduino library. The following code provides the necessary instructions in the Arduino language specifically for this sensor.</p> <pre><code>#include \"HX711.h\"\n// HX711 Amplificador\nconst int LOADCELL_DOUT_PIN = 1;\nconst int LOADCELL_SCK_PIN = 5;\nHX711 scale;\ndouble p;\n//...\nvoid setup() {\nSerial.begin(115200);  //...\nscale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);\nscale.set_scale(417.6153340635268);\nscale.tare();\npinMode(enA, OUTPUT);\npinMode(in1, OUTPUT);\npinMode(in2, OUTPUT);\n//...\n}\nvoid loop() {\np=scale.get_units(30);\n//...\nSerial.println(p,4); //...       \n}\n</code></pre>"},{"location":"documentacion/#current-sensor","title":"Current Sensor","text":"<p>The subsequent code displays the essential instructions in the Arduino language specifically for this sensor.</p> <pre><code>float sensibility=0.285;\nvoid setup() {\n// put your setup code here, to run once:\nSerial.begin(115200);  /...\npinMode(enA, OUTPUT);\npinMode(in1, OUTPUT);\npinMode(in2, OUTPUT);\n}\nfloat get_corriente(int n_muestras){\nfloat voltajeSensor;\nfloat corriente=0;\nfor(int i=0;i&lt;n_muestras;i++){\nvoltajeSensor = analogRead(A0) * (5.00 / 1023.00);////Sensor Reading\ncorriente=corriente+(voltajeSensor - 3.8331)/Sensibilidad; //get the current\n}\ncorriente=corriente/n_muestras;\nreturn(corriente);\n}\nvoid loop() {\nc=get_corriente(20);\n//...\nSerial.println(c,4); //...       \n}\n</code></pre>"},{"location":"documentacion/#actuator","title":"Actuator","text":""},{"location":"documentacion/#motor-driver","title":"Motor Driver","text":"<p>The following code provides the requisite instructions in the Arduino language specifically for the motor driver.</p> <pre><code>int enA = 2;\nint in1 = 4;\nint in2 = 3;\nvoid setup() {\nSerial.begin(115200);  //...\npinMode(enA, OUTPUT);\npinMode(in1, OUTPUT);\npinMode(in2, OUTPUT);\n}\nvoid speedControl(int velocidad) {\ndigitalWrite(in1, LOW);\ndigitalWrite(in2, HIGH);\nanalogWrite(enA, velocidad);\ndelay(3500);\n//...\nanalogWrite(enA,0);\n}\nvoid loop() {\n//...\ndouble x1;\nif (Serial.available() &gt; 0){\nfloat data = Serial.parseFloat();\nif (data&gt;0){\nx1= int(data);\nspeedControl(x1);\n}\n//...\n}\n/...\n}\n</code></pre>"},{"location":"documentacion/#complete-arduino-code","title":"Complete Arduino Code","text":"<p>The comprehensive code integrates the sensors, actuator, and facilitates serial communication. You can download it here</p>"},{"location":"lab/","title":"The Laboratory","text":"<p>The Arduino board, along with its connections to the sensors and actuators components, is depicted in the following image.</p> <p></p> <p>The testbench, which houses the motor-propeller assembly, water reservoir, and thrust sensing, is depicted in the following image.</p> <p></p>"},{"location":"r/","title":"R-Studio","text":"<p>For the R code to function properly, two components are essential:</p> <ol> <li>The optimization function </li> <li>The Genetic algorithm</li> </ol>"},{"location":"r/#functions-to-optimize","title":"Functions to optimize","text":""},{"location":"r/#thrust-current-function","title":"Thrust current function","text":"<p>This function adjusts the PWM signal to optimize the ratio between thrust and current.</p> <p>Thrust current Code</p>"},{"location":"r/#maximum-thrust-function","title":"Maximum Thrust function","text":"<p>This function adjusts the PWM signal and aims to identify the peak thrust.</p> <p>Thrust current Code</p>"},{"location":"r/#minimum-thrust-function","title":"Minimum Thrust function","text":"<p>This function adjusts the PWM signal to ascertain the least thrust value greater than zero.</p> <p>Thrust current Code</p>"},{"location":"r/#the-genetic-algorithmn","title":"The genetic algorithmn","text":"<p>To execute the genetic algorithm effectively, a suite of functions is required. These functions cater to various stages such as initialization, data transformation, communication, and storage.</p>"},{"location":"r/#genetic-algorithmn-code","title":"Genetic algorithmn code","text":"<p>Algorithmn for R, Initializer</p> <p>Algorithmn for R, Data transformation </p> <p>Algorithmn for R, connection and Genetic Algorithm </p>"},{"location":"r/#storage","title":"Storage","text":"<p>Storage </p>"},{"location":"resultados/","title":"Result","text":""},{"location":"resultados/#results-with-r","title":"Results with R","text":"<p>The outcomes from various test instances are consolidated in the subsequent zip file.</p> <p>Results with R + Arduino</p>"},{"location":"sensores/","title":"Sensors","text":""},{"location":"sensores/#trust-sensor","title":"Trust sensor","text":"<p>To quantify the propeller's thrust, a 5kg strain gauge is utilized. This gauge necessitates an amplifier; for this purpose, the HX711 was employed.</p> <p> </p>"},{"location":"sensores/#current-sensor","title":"Current Sensor","text":"<p>The sensor depicted in the image, the ACS712, is used to measure the power consumption of the motor across varying intensities during the experiment.</p> <p></p>"}]}